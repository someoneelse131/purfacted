// ============================================
// PurFacted - Prisma Database Schema
// ============================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Enums
// ============================================

enum UserType {
  ANONYMOUS
  VERIFIED
  EXPERT
  PHD
  ORGANIZATION
  MODERATOR
}

enum NotificationType {
  TRUST_CHANGE
  FACT_REPLY
  FACT_DISPUTED
  VETO_RECEIVED
  VERIFICATION_RESULT
  ORG_COMMENT
  DEBATE_REQUEST
  DEBATE_PUBLISHED
  MODERATOR_STATUS
  FACT_STATUS
}

// ============================================
// User & Authentication
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  firstName     String
  lastName      String
  passwordHash  String
  emailVerified Boolean   @default(false)
  userType      UserType  @default(VERIFIED)
  trustScore    Int       @default(10)
  banLevel      Int       @default(0)
  bannedUntil   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?

  // Soft delete
  deletedAt     DateTime?

  // Pending email change (requires verification)
  pendingEmail  String?

  // Relations
  sessions                Session[]
  emailVerifications      EmailVerification[]
  passwordResets          PasswordReset[]
  notificationPreferences NotificationPreference[]
  facts                   Fact[]
  sources                 Source[]
  factEdits               FactEdit[]
  factEditsReviewed       FactEdit[]             @relation("FactEditReviewer")
  factVotes               FactVote[]
  vetos                   Veto[]
  vetoVotes               VetoVote[]
  categoriesCreated       Category[]             @relation("CategoryCreator")
  categoryMergeRequests   CategoryMergeRequest[]
  categoryMergeVotes      CategoryMergeVote[]

  @@map("users")
}

model Session {
  id        String   @id
  userId    String
  expiresAt DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model EmailVerification {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("email_verifications")
}

model PasswordReset {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("password_resets")
}

model NotificationPreference {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  email     Boolean          @default(true)
  inApp     Boolean          @default(true)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@index([userId])
  @@map("notification_preferences")
}

// ============================================
// Configuration Tables
// ============================================

enum TrustAction {
  FACT_APPROVED
  FACT_WRONG
  FACT_OUTDATED
  VETO_SUCCESS
  VETO_FAIL
  VERIFICATION_CORRECT
  VERIFICATION_WRONG
  UPVOTED
  DOWNVOTED
}

model TrustScoreConfig {
  id        String      @id @default(cuid())
  action    TrustAction @unique
  points    Int
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@map("trust_score_config")
}

model VoteWeightConfig {
  id         String   @id @default(cuid())
  userType   UserType @unique
  baseWeight Float
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("vote_weight_config")
}

model TrustModifierConfig {
  id           String   @id @default(cuid())
  minTrust     Int
  maxTrust     Int?
  modifier     Float
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("trust_modifier_config")
}

// ============================================
// Anonymous Voting
// ============================================

model AnonymousVote {
  id           String   @id @default(cuid())
  ipHash       String   // Hashed IP for privacy
  contentType  String   // "fact", "discussion", "comment"
  contentId    String
  value        Int      // 1 for upvote, -1 for downvote
  weight       Float    @default(0.1)
  captchaToken String?  // Optional captcha verification token
  createdAt    DateTime @default(now())

  @@unique([ipHash, contentType, contentId])
  @@index([ipHash, createdAt])
  @@index([contentType, contentId])
  @@map("anonymous_votes")
}

model IpRateLimit {
  id        String   @id @default(cuid())
  ipHash    String   @unique
  voteCount Int      @default(0)
  resetAt   DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ipHash])
  @@map("ip_rate_limits")
}

// ============================================
// Fact System
// ============================================

enum FactStatus {
  SUBMITTED
  IN_REVIEW
  PROVEN
  DISPROVEN
  CONTROVERSIAL
  UNDER_VETO_REVIEW
}

enum SourceType {
  PEER_REVIEWED
  OFFICIAL
  NEWS
  COMPANY
  BLOG
  OTHER
}

model Fact {
  id            String     @id @default(cuid())
  title         String
  body          String
  status        FactStatus @default(SUBMITTED)
  userId        String
  categoryId    String?
  duplicateOfId String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  category    Category?   @relation(fields: [categoryId], references: [id])
  duplicateOf Fact?       @relation("FactDuplicates", fields: [duplicateOfId], references: [id])
  duplicates  Fact[]      @relation("FactDuplicates")
  sources     Source[]
  edits       FactEdit[]
  votes       FactVote[]
  vetos       Veto[]

  @@index([userId])
  @@index([categoryId])
  @@index([status])
  @@index([createdAt])
  @@map("facts")
}

model Source {
  id          String     @id @default(cuid())
  factId      String
  url         String
  title       String?
  type        SourceType @default(OTHER)
  credibility Int        @default(50) // 0-100 scale
  addedById   String
  createdAt   DateTime   @default(now())

  // Relations
  fact    Fact @relation(fields: [factId], references: [id], onDelete: Cascade)
  addedBy User @relation(fields: [addedById], references: [id])

  @@index([factId])
  @@index([addedById])
  @@map("sources")
}

enum FactEditStatus {
  PENDING
  APPROVED
  REJECTED
}

model FactEdit {
  id           String         @id @default(cuid())
  factId       String
  oldBody      String
  newBody      String
  userId       String
  status       FactEditStatus @default(PENDING)
  reviewedById String?
  createdAt    DateTime       @default(now())
  reviewedAt   DateTime?

  // Relations
  fact       Fact  @relation(fields: [factId], references: [id], onDelete: Cascade)
  user       User  @relation(fields: [userId], references: [id])
  reviewedBy User? @relation("FactEditReviewer", fields: [reviewedById], references: [id])

  @@index([factId])
  @@index([userId])
  @@index([status])
  @@map("fact_edits")
}

model Category {
  id              String   @id @default(cuid())
  name            String   @unique
  parentId        String?
  createdByUserId String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  facts             Fact[]
  aliases           CategoryAlias[]
  parent            Category?              @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children          Category[]             @relation("CategoryHierarchy")
  createdBy         User?                  @relation("CategoryCreator", fields: [createdByUserId], references: [id])
  mergeRequestsFrom CategoryMergeRequest[] @relation("MergeFrom")
  mergeRequestsTo   CategoryMergeRequest[] @relation("MergeTo")

  @@index([parentId])
  @@index([createdByUserId])
  @@map("categories")
}

model CategoryAlias {
  id         String   @id @default(cuid())
  name       String   @unique
  categoryId String
  createdAt  DateTime @default(now())

  // Relations
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@index([categoryId])
  @@map("category_aliases")
}

// ============================================
// Fact Votes
// ============================================

model FactVote {
  id        String   @id @default(cuid())
  factId    String
  userId    String
  value     Int      // 1 for upvote, -1 for downvote
  weight    Float    // Vote weight at time of vote
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  fact Fact @relation(fields: [factId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([factId, userId])
  @@index([factId])
  @@index([userId])
  @@map("fact_votes")
}

// ============================================
// Source Credibility Configuration
// ============================================

model SourceCredibilityConfig {
  id         String     @id @default(cuid())
  sourceType SourceType @unique
  points     Int
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@map("source_credibility_config")
}

// ============================================
// Veto System
// ============================================

enum VetoStatus {
  PENDING
  APPROVED
  REJECTED
}

model Veto {
  id          String     @id @default(cuid())
  factId      String
  userId      String
  reason      String
  status      VetoStatus @default(PENDING)
  createdAt   DateTime   @default(now())
  resolvedAt  DateTime?

  // Relations
  fact    Fact         @relation(fields: [factId], references: [id], onDelete: Cascade)
  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  sources VetoSource[]
  votes   VetoVote[]

  @@index([factId])
  @@index([userId])
  @@index([status])
  @@map("vetos")
}

model VetoSource {
  id        String     @id @default(cuid())
  vetoId    String
  url       String
  title     String?
  type      SourceType @default(OTHER)
  createdAt DateTime   @default(now())

  // Relations
  veto Veto @relation(fields: [vetoId], references: [id], onDelete: Cascade)

  @@index([vetoId])
  @@map("veto_sources")
}

model VetoVote {
  id        String   @id @default(cuid())
  vetoId    String
  userId    String
  value     Int      // 1 for approve, -1 for reject
  weight    Float
  createdAt DateTime @default(now())

  // Relations
  veto Veto @relation(fields: [vetoId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([vetoId, userId])
  @@index([vetoId])
  @@index([userId])
  @@map("veto_votes")
}

// ============================================
// Category Merge Requests
// ============================================

enum MergeRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model CategoryMergeRequest {
  id             String             @id @default(cuid())
  fromCategoryId String
  toCategoryId   String
  requestedById  String
  status         MergeRequestStatus @default(PENDING)
  createdAt      DateTime           @default(now())
  resolvedAt     DateTime?

  // Relations
  fromCategory Category @relation("MergeFrom", fields: [fromCategoryId], references: [id], onDelete: Cascade)
  toCategory   Category @relation("MergeTo", fields: [toCategoryId], references: [id], onDelete: Cascade)
  requestedBy  User     @relation(fields: [requestedById], references: [id], onDelete: Cascade)
  votes        CategoryMergeVote[]

  @@index([fromCategoryId])
  @@index([toCategoryId])
  @@index([status])
  @@map("category_merge_requests")
}

model CategoryMergeVote {
  id             String   @id @default(cuid())
  mergeRequestId String
  userId         String
  value          Int      // 1 for approve, -1 for reject
  createdAt      DateTime @default(now())

  // Relations
  mergeRequest CategoryMergeRequest @relation(fields: [mergeRequestId], references: [id], onDelete: Cascade)
  user         User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([mergeRequestId, userId])
  @@index([mergeRequestId])
  @@index([userId])
  @@map("category_merge_votes")
}
