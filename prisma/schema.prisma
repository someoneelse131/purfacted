// ============================================
// PurFacted - Prisma Database Schema
// ============================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Enums
// ============================================

enum UserType {
  ANONYMOUS
  VERIFIED
  EXPERT
  PHD
  ORGANIZATION
  MODERATOR
}

enum NotificationType {
  TRUST_CHANGE
  FACT_REPLY
  FACT_DISPUTED
  VETO_RECEIVED
  VERIFICATION_RESULT
  ORG_COMMENT
  DEBATE_REQUEST
  DEBATE_PUBLISHED
  MODERATOR_STATUS
  FACT_STATUS
}

// ============================================
// User & Authentication
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  firstName     String
  lastName      String
  passwordHash  String
  emailVerified Boolean   @default(false)
  userType      UserType  @default(VERIFIED)
  trustScore    Int       @default(10)
  banLevel      Int       @default(0)
  bannedUntil   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?

  // Soft delete
  deletedAt     DateTime?

  // Pending email change (requires verification)
  pendingEmail  String?

  // Relations
  sessions                Session[]
  emailVerifications      EmailVerification[]
  passwordResets          PasswordReset[]
  notificationPreferences NotificationPreference[]
  facts                   Fact[]
  sources                 Source[]
  factEdits               FactEdit[]
  factEditsReviewed       FactEdit[]             @relation("FactEditReviewer")
  factVotes               FactVote[]
  vetos                   Veto[]
  vetoVotes               VetoVote[]
  categoriesCreated       Category[]             @relation("CategoryCreator")
  categoryMergeRequests   CategoryMergeRequest[]
  categoryMergeVotes      CategoryMergeVote[]
  discussions             Discussion[]
  discussionVotes         DiscussionVote[]
  comments                Comment[]
  commentVotes            CommentVote[]
  debatesInitiated        Debate[]               @relation("DebateInitiator")
  debatesParticipated     Debate[]               @relation("DebateParticipant")
  debateMessages          DebateMessage[]
  debateVotes             DebateVote[]
  blocksMade              UserBlock[]            @relation("BlocksMade")
  blocksReceived          UserBlock[]            @relation("BlocksReceived")
  reportsMade             Report[]               @relation("ReportsMade")
  reportsReviewed         Report[]               @relation("ReportsReviewed")
  orgTagsReceived         OrganizationTag[]      @relation("OrgTagsReceived")
  orgTagsMade             OrganizationTag[]      @relation("OrgTagsMade")
  officialComments        OfficialComment[]
  expertVerifications     ExpertVerification[]
  verificationReviews     VerificationReview[]
  trustVotesMade          UserTrustVote[]        @relation("TrustVotesMade")
  trustVotesReceived      UserTrustVote[]        @relation("TrustVotesReceived")
  bansReceived            Ban[]                  @relation("BansReceived")
  bansGiven               Ban[]                  @relation("BansGiven")
  flagsReceived           AccountFlag[]          @relation("FlagsReceived")
  flagsReviewed           AccountFlag[]          @relation("FlagsReviewed")

  @@map("users")
}

model Session {
  id        String   @id
  userId    String
  expiresAt DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model EmailVerification {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("email_verifications")
}

model PasswordReset {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("password_resets")
}

model NotificationPreference {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  email     Boolean          @default(true)
  inApp     Boolean          @default(true)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@index([userId])
  @@map("notification_preferences")
}

// ============================================
// Configuration Tables
// ============================================

enum TrustAction {
  FACT_APPROVED
  FACT_WRONG
  FACT_OUTDATED
  VETO_SUCCESS
  VETO_FAIL
  VERIFICATION_CORRECT
  VERIFICATION_WRONG
  UPVOTED
  DOWNVOTED
}

model TrustScoreConfig {
  id        String      @id @default(cuid())
  action    TrustAction @unique
  points    Int
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@map("trust_score_config")
}

model VoteWeightConfig {
  id         String   @id @default(cuid())
  userType   UserType @unique
  baseWeight Float
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("vote_weight_config")
}

model TrustModifierConfig {
  id           String   @id @default(cuid())
  minTrust     Int
  maxTrust     Int?
  modifier     Float
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("trust_modifier_config")
}

// ============================================
// Anonymous Voting
// ============================================

model AnonymousVote {
  id           String   @id @default(cuid())
  ipHash       String   // Hashed IP for privacy
  contentType  String   // "fact", "discussion", "comment"
  contentId    String
  value        Int      // 1 for upvote, -1 for downvote
  weight       Float    @default(0.1)
  captchaToken String?  // Optional captcha verification token
  createdAt    DateTime @default(now())

  @@unique([ipHash, contentType, contentId])
  @@index([ipHash, createdAt])
  @@index([contentType, contentId])
  @@map("anonymous_votes")
}

model IpRateLimit {
  id        String   @id @default(cuid())
  ipHash    String   @unique
  voteCount Int      @default(0)
  resetAt   DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ipHash])
  @@map("ip_rate_limits")
}

// ============================================
// Fact System
// ============================================

enum FactStatus {
  SUBMITTED
  IN_REVIEW
  PROVEN
  DISPROVEN
  CONTROVERSIAL
  UNDER_VETO_REVIEW
}

enum SourceType {
  PEER_REVIEWED
  OFFICIAL
  NEWS
  COMPANY
  BLOG
  OTHER
}

model Fact {
  id            String     @id @default(cuid())
  title         String
  body          String
  status        FactStatus @default(SUBMITTED)
  userId        String
  categoryId    String?
  duplicateOfId String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  category    Category?   @relation(fields: [categoryId], references: [id])
  duplicateOf Fact?       @relation("FactDuplicates", fields: [duplicateOfId], references: [id])
  duplicates  Fact[]      @relation("FactDuplicates")
  sources     Source[]
  edits       FactEdit[]
  votes       FactVote[]
  vetos       Veto[]
  discussions      Discussion[]
  comments         Comment[]
  debates          Debate[]
  organizationTags OrganizationTag[]
  officialComments OfficialComment[]

  @@index([userId])
  @@index([categoryId])
  @@index([status])
  @@index([createdAt])
  @@map("facts")
}

model Source {
  id          String     @id @default(cuid())
  factId      String
  url         String
  title       String?
  type        SourceType @default(OTHER)
  credibility Int        @default(50) // 0-100 scale
  addedById   String
  createdAt   DateTime   @default(now())

  // Relations
  fact    Fact @relation(fields: [factId], references: [id], onDelete: Cascade)
  addedBy User @relation(fields: [addedById], references: [id])

  @@index([factId])
  @@index([addedById])
  @@map("sources")
}

enum FactEditStatus {
  PENDING
  APPROVED
  REJECTED
}

model FactEdit {
  id           String         @id @default(cuid())
  factId       String
  oldBody      String
  newBody      String
  userId       String
  status       FactEditStatus @default(PENDING)
  reviewedById String?
  createdAt    DateTime       @default(now())
  reviewedAt   DateTime?

  // Relations
  fact       Fact  @relation(fields: [factId], references: [id], onDelete: Cascade)
  user       User  @relation(fields: [userId], references: [id])
  reviewedBy User? @relation("FactEditReviewer", fields: [reviewedById], references: [id])

  @@index([factId])
  @@index([userId])
  @@index([status])
  @@map("fact_edits")
}

model Category {
  id              String   @id @default(cuid())
  name            String   @unique
  parentId        String?
  createdByUserId String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  facts             Fact[]
  aliases           CategoryAlias[]
  parent            Category?              @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children          Category[]             @relation("CategoryHierarchy")
  createdBy         User?                  @relation("CategoryCreator", fields: [createdByUserId], references: [id])
  mergeRequestsFrom CategoryMergeRequest[] @relation("MergeFrom")
  mergeRequestsTo   CategoryMergeRequest[] @relation("MergeTo")

  @@index([parentId])
  @@index([createdByUserId])
  @@map("categories")
}

model CategoryAlias {
  id         String   @id @default(cuid())
  name       String   @unique
  categoryId String
  createdAt  DateTime @default(now())

  // Relations
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@index([categoryId])
  @@map("category_aliases")
}

// ============================================
// Fact Votes
// ============================================

model FactVote {
  id        String   @id @default(cuid())
  factId    String
  userId    String
  value     Int      // 1 for upvote, -1 for downvote
  weight    Float    // Vote weight at time of vote
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  fact Fact @relation(fields: [factId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([factId, userId])
  @@index([factId])
  @@index([userId])
  @@map("fact_votes")
}

// ============================================
// Source Credibility Configuration
// ============================================

model SourceCredibilityConfig {
  id         String     @id @default(cuid())
  sourceType SourceType @unique
  points     Int
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@map("source_credibility_config")
}

// ============================================
// Veto System
// ============================================

enum VetoStatus {
  PENDING
  APPROVED
  REJECTED
}

model Veto {
  id          String     @id @default(cuid())
  factId      String
  userId      String
  reason      String
  status      VetoStatus @default(PENDING)
  createdAt   DateTime   @default(now())
  resolvedAt  DateTime?

  // Relations
  fact    Fact         @relation(fields: [factId], references: [id], onDelete: Cascade)
  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  sources VetoSource[]
  votes   VetoVote[]

  @@index([factId])
  @@index([userId])
  @@index([status])
  @@map("vetos")
}

model VetoSource {
  id        String     @id @default(cuid())
  vetoId    String
  url       String
  title     String?
  type      SourceType @default(OTHER)
  createdAt DateTime   @default(now())

  // Relations
  veto Veto @relation(fields: [vetoId], references: [id], onDelete: Cascade)

  @@index([vetoId])
  @@map("veto_sources")
}

model VetoVote {
  id        String   @id @default(cuid())
  vetoId    String
  userId    String
  value     Int      // 1 for approve, -1 for reject
  weight    Float
  createdAt DateTime @default(now())

  // Relations
  veto Veto @relation(fields: [vetoId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([vetoId, userId])
  @@index([vetoId])
  @@index([userId])
  @@map("veto_votes")
}

// ============================================
// Category Merge Requests
// ============================================

enum MergeRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model CategoryMergeRequest {
  id             String             @id @default(cuid())
  fromCategoryId String
  toCategoryId   String
  requestedById  String
  status         MergeRequestStatus @default(PENDING)
  createdAt      DateTime           @default(now())
  resolvedAt     DateTime?

  // Relations
  fromCategory Category @relation("MergeFrom", fields: [fromCategoryId], references: [id], onDelete: Cascade)
  toCategory   Category @relation("MergeTo", fields: [toCategoryId], references: [id], onDelete: Cascade)
  requestedBy  User     @relation(fields: [requestedById], references: [id], onDelete: Cascade)
  votes        CategoryMergeVote[]

  @@index([fromCategoryId])
  @@index([toCategoryId])
  @@index([status])
  @@map("category_merge_requests")
}

model CategoryMergeVote {
  id             String   @id @default(cuid())
  mergeRequestId String
  userId         String
  value          Int      // 1 for approve, -1 for reject
  createdAt      DateTime @default(now())

  // Relations
  mergeRequest CategoryMergeRequest @relation(fields: [mergeRequestId], references: [id], onDelete: Cascade)
  user         User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([mergeRequestId, userId])
  @@index([mergeRequestId])
  @@index([userId])
  @@map("category_merge_votes")
}

// ============================================
// Discussion System
// ============================================

enum DiscussionType {
  PRO
  CONTRA
  NEUTRAL
}

model Discussion {
  id        String         @id @default(cuid())
  factId    String
  userId    String
  type      DiscussionType
  body      String
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  // Relations
  fact  Fact             @relation(fields: [factId], references: [id], onDelete: Cascade)
  user  User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  votes DiscussionVote[]

  @@index([factId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("discussions")
}

model DiscussionVote {
  id           String   @id @default(cuid())
  discussionId String
  userId       String
  value        Int      // 1 for upvote, -1 for downvote
  weight       Float    // Vote weight at time of vote
  createdAt    DateTime @default(now())

  // Relations
  discussion Discussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([discussionId, userId])
  @@index([discussionId])
  @@index([userId])
  @@map("discussion_votes")
}

// ============================================
// Comment System
// ============================================

model Comment {
  id        String   @id @default(cuid())
  factId    String
  userId    String
  body      String
  parentId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  fact     Fact          @relation(fields: [factId], references: [id], onDelete: Cascade)
  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent   Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[]     @relation("CommentReplies")
  votes    CommentVote[]

  @@index([factId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@map("comments")
}

model CommentVote {
  id        String   @id @default(cuid())
  commentId String
  userId    String
  value     Int      // 1 for upvote, -1 for downvote
  weight    Float    // Vote weight at time of vote
  createdAt DateTime @default(now())

  // Relations
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
  @@map("comment_votes")
}

// ============================================
// Debate System
// ============================================

enum DebateStatus {
  PENDING    // Awaiting participant acceptance
  ACTIVE     // In progress
  PUBLISHED  // Made public
  DECLINED   // Participant declined
  EXPIRED    // No response within time limit
}

model Debate {
  id            String       @id @default(cuid())
  factId        String
  initiatorId   String
  participantId String
  title         String?      // Required for publishing
  status        DebateStatus @default(PENDING)
  publishedAt   DateTime?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // Relations
  fact        Fact            @relation(fields: [factId], references: [id], onDelete: Cascade)
  initiator   User            @relation("DebateInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  participant User            @relation("DebateParticipant", fields: [participantId], references: [id], onDelete: Cascade)
  messages    DebateMessage[]
  votes       DebateVote[]

  @@index([factId])
  @@index([initiatorId])
  @@index([participantId])
  @@index([status])
  @@index([createdAt])
  @@map("debates")
}

model DebateMessage {
  id        String   @id @default(cuid())
  debateId  String
  userId    String
  body      String
  createdAt DateTime @default(now())

  // Relations
  debate Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([debateId])
  @@index([userId])
  @@index([createdAt])
  @@map("debate_messages")
}

model DebateVote {
  id        String   @id @default(cuid())
  debateId  String
  userId    String
  value     Int      // 1 for upvote, -1 for downvote
  weight    Float
  createdAt DateTime @default(now())

  // Relations
  debate Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([debateId, userId])
  @@index([debateId])
  @@index([userId])
  @@map("debate_votes")
}

// ============================================
// User Blocking
// ============================================

model UserBlock {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  // Relations
  blocker User @relation("BlocksMade", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("BlocksReceived", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("user_blocks")
}

// ============================================
// Content Reporting
// ============================================

enum ContentType {
  FACT
  DISCUSSION
  COMMENT
  DEBATE
  USER
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}

model Report {
  id           String       @id @default(cuid())
  reporterId   String
  contentType  ContentType
  contentId    String
  reason       String
  details      String?
  status       ReportStatus @default(PENDING)
  reviewedById String?
  resolution   String?
  createdAt    DateTime     @default(now())
  resolvedAt   DateTime?

  // Relations
  reporter   User  @relation("ReportsMade", fields: [reporterId], references: [id], onDelete: Cascade)
  reviewedBy User? @relation("ReportsReviewed", fields: [reviewedById], references: [id])

  @@index([reporterId])
  @@index([contentType, contentId])
  @@index([status])
  @@index([reviewedById])
  @@map("reports")
}

// ============================================
// Organization Tagging
// ============================================

model OrganizationTag {
  id        String   @id @default(cuid())
  factId    String
  orgUserId String
  taggedById String?  // null if auto-tagged by keyword
  isDisputed Boolean @default(false)
  createdAt DateTime @default(now())

  // Relations
  fact     Fact  @relation(fields: [factId], references: [id], onDelete: Cascade)
  orgUser  User  @relation("OrgTagsReceived", fields: [orgUserId], references: [id], onDelete: Cascade)
  taggedBy User? @relation("OrgTagsMade", fields: [taggedById], references: [id])

  @@unique([factId, orgUserId])
  @@index([factId])
  @@index([orgUserId])
  @@map("organization_tags")
}

model OfficialComment {
  id        String   @id @default(cuid())
  factId    String
  orgUserId String
  body      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  fact    Fact @relation(fields: [factId], references: [id], onDelete: Cascade)
  orgUser User @relation(fields: [orgUserId], references: [id], onDelete: Cascade)

  @@index([factId])
  @@index([orgUserId])
  @@map("official_comments")
}

// ============================================
// Expert Verification System
// ============================================

enum VerificationType {
  EXPERT
  PHD
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

model ExpertVerification {
  id          String             @id @default(cuid())
  userId      String
  type        VerificationType
  documentUrl String             // Path/URL to uploaded diploma
  field       String             // Area of expertise (e.g., "Computer Science")
  status      VerificationStatus @default(PENDING)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  // Relations
  user    User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviews VerificationReview[]

  @@index([userId])
  @@index([status])
  @@index([type])
  @@map("expert_verifications")
}

model VerificationReview {
  id             String   @id @default(cuid())
  verificationId String
  reviewerId     String
  approved       Boolean
  comment        String?
  createdAt      DateTime @default(now())

  // Relations
  verification ExpertVerification @relation(fields: [verificationId], references: [id], onDelete: Cascade)
  reviewer     User               @relation(fields: [reviewerId], references: [id], onDelete: Cascade)

  @@unique([verificationId, reviewerId])
  @@index([verificationId])
  @@index([reviewerId])
  @@map("verification_reviews")
}

// ============================================
// User Trust Voting
// ============================================

model UserTrustVote {
  id        String   @id @default(cuid())
  voterId   String
  targetId  String
  value     Int      // 1 for upvote, -1 for downvote
  createdAt DateTime @default(now())

  // Relations
  voter  User @relation("TrustVotesMade", fields: [voterId], references: [id], onDelete: Cascade)
  target User @relation("TrustVotesReceived", fields: [targetId], references: [id], onDelete: Cascade)

  @@index([voterId, createdAt])
  @@index([targetId])
  @@map("user_trust_votes")
}

// ============================================
// Ban System
// ============================================

model Ban {
  id          String    @id @default(cuid())
  userId      String
  level       Int       // 1, 2, or 3 (permanent)
  reason      String
  bannedById  String?
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())

  // Relations
  user     User  @relation("BansReceived", fields: [userId], references: [id], onDelete: Cascade)
  bannedBy User? @relation("BansGiven", fields: [bannedById], references: [id])

  @@index([userId])
  @@index([bannedById])
  @@index([expiresAt])
  @@map("bans")
}

model BannedEmail {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())

  @@map("banned_emails")
}

model BannedIp {
  id        String   @id @default(cuid())
  ipHash    String   @unique
  createdAt DateTime @default(now())

  @@map("banned_ips")
}

// ============================================
// Account Flagging
// ============================================

model AccountFlag {
  id         String    @id @default(cuid())
  userId     String
  reason     String
  details    String?
  status     String    @default("PENDING") // PENDING, REVIEWING, RESOLVED, DISMISSED
  reviewedById String?
  resolution String?
  createdAt  DateTime  @default(now())
  resolvedAt DateTime?

  // Relations
  user       User  @relation("FlagsReceived", fields: [userId], references: [id], onDelete: Cascade)
  reviewedBy User? @relation("FlagsReviewed", fields: [reviewedById], references: [id])

  @@index([userId])
  @@index([status])
  @@index([reviewedById])
  @@map("account_flags")
}
